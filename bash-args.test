# Copyright (c) 2025 Mihai Stancu (https://github.com/curatorium)

source bash-args.sh;

# Smoke Tests — bare invocation, happy path
#------------------------------------------------------------------------------

test:smoke:flag:long() {
	local ARGS=(--verbose);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:smoke:flag:short() {
	local ARGS=(-v);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:smoke:flag:absent() {
	local ARGS=();
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "" || return 1;
}

test:smoke:opt:long-space() {
	local ARGS=(--name foo);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:smoke:opt:short-space() {
	local ARGS=(-n foo);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:smoke:opt:absent() {
	local ARGS=();
	local name;
	args:opt name n || return 1;
	assert "$name" "" || return 1;
}

test:smoke:arg:positional() {
	local ARGS=(foo);
	local file;
	args:arg file || return 1;
	assert "$file" "foo" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:smoke:arg:missing() {
	local ARGS=();
	local file;
	args:arg file 2>/dev/null && return 1;
	return 0;
}

test:smoke:arg:optional-missing() {
	local ARGS=();
	local file;
	args:arg -o file || return 1;
	assert "$file" "" || return 1;
}

test:smoke:varg:variadic() {
	local ARGS=(a b c);
	local files;
	args:varg files || return 1;
	assert:array-eq files "a b c" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:smoke:varg:missing() {
	local ARGS=();
	local files;
	args:varg files 2>/dev/null && return 1;
	return 0;
}

test:smoke:varg:optional-missing() {
	local ARGS=();
	local files;
	args:varg -o files || return 1;
	assert:array-eq files "" || return 1;
}

test:smoke:sub:match() {
	local ARGS=(--verbose clone https://repo);
	local cmd sub_args=();
	args:sub cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "clone" || return 1;
	assert:array-eq sub_args "https://repo" || return 1;
	assert:array-eq ARGS "--verbose" || return 1;
}

test:smoke:sub:missing() {
	local ARGS=();
	local cmd sub_args=();
	args:sub cmd sub_args '^([a-z]+)$' 2>/dev/null && return 1;
	return 0;
}

test:smoke:sub:optional-missing() {
	local ARGS=();
	local cmd sub_args=();
	args:sub -o cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "" || return 1;
}

# Feature Tests — one feature at a time
#------------------------------------------------------------------------------

# --required / --optional
#--------------------------------------

test:feature:flag:required-found() {
	local ARGS=(--verbose);
	local verbose;
	args:flag -r verbose v || return 1;
	assert "$verbose" "true" || return 1;
}

test:feature:flag:required-missing() {
	local ARGS=();
	local verbose;
	args:flag -r verbose v 2>/dev/null && return 1;
	return 0;
}

test:feature:flag:required-multiple() {
	local ARGS=(-v -v);
	local verbose;
	args:flag -r verbose v || return 1;
	assert "$verbose" "true" || return 1;
}

test:feature:flag:required-after-sep() {
	local ARGS=(-- -v);
	local verbose;
	args:flag -r verbose v 2>/dev/null && return 1;
	return 0;
}

test:feature:opt:required-found() {
	local ARGS=(--name foo);
	local name;
	args:opt -r name n || return 1;
	assert "$name" "foo" || return 1;
}

test:feature:opt:required-missing() {
	local ARGS=();
	local name;
	args:opt -r name n 2>/dev/null && return 1;
	return 0;
}

test:feature:opt:required-long-only-absent() {
	local ARGS=();
	local name;
	args:opt -r name "" 2>/dev/null && return 1;
	return 0;
}

test:feature:arg:optional-present() {
	local ARGS=(foo);
	local file;
	args:arg -o file || return 1;
	assert "$file" "foo" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:arg:optional-pattern-match() {
	local ARGS=(123);
	local num;
	args:arg -o num '^[0-9]+$' || return 1;
	assert "$num" "123" || return 1;
}

test:feature:arg:optional-pattern-mismatch() {
	local ARGS=(abc);
	local num;
	args:arg -o num '^[0-9]+$' || return 1;
	assert "$num" "" || return 1;
	assert:array-eq ARGS "abc" || return 1;
}

test:feature:varg:single-arg() {
	local ARGS=(single);
	local files;
	args:varg files || return 1;
	assert:array-eq files "single" || return 1;
}

test:feature:varg:optional-present() {
	local ARGS=(a b c);
	local files;
	args:varg -o files || return 1;
	assert:array-eq files "a b c" || return 1;
}

test:feature:varg:optional-single() {
	local ARGS=(single);
	local files;
	args:varg -o files || return 1;
	assert:array-eq files "single" || return 1;
}

test:feature:sub:optional-match() {
	local ARGS=(clone https://repo);
	local cmd sub_args=();
	args:sub -o cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "clone" || return 1;
}

test:feature:sub:required-mismatch() {
	local ARGS=(--verbose --force);
	local cmd sub_args=();
	args:sub cmd sub_args '^([a-z]+)$' 2>/dev/null && return 1;
	return 0;
}

test:feature:sub:optional-mismatch() {
	local ARGS=(--verbose --force);
	local cmd sub_args=();
	args:sub -o cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "" || return 1;
}

test:feature:sub:flags-before() {
	local ARGS=(--verbose --force clone https://repo);
	local cmd sub_args=();
	args:sub cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "clone" || return 1;
	assert:array-eq ARGS "--verbose --force" || return 1;
}

# long-only (short="")
#--------------------------------------

test:feature:flag:long-only() {
	local ARGS=(--verbose);
	local verbose;
	args:flag verbose "" || return 1;
	assert "$verbose" "true" || return 1;
}

test:feature:flag:long-only-ignores-short() {
	local ARGS=(-v);
	local verbose;
	args:flag verbose "" || return 1;
	assert "$verbose" "" || return 1;
	assert:array-eq ARGS "-v" || return 1;
}

test:feature:flag:long-only-absent() {
	local ARGS=();
	local verbose;
	args:flag verbose "" || return 1;
	assert "$verbose" "" || return 1;
}

test:feature:opt:long-only() {
	local ARGS=(--name foo);
	local name;
	args:opt name "" || return 1;
	assert "$name" "foo" || return 1;
}

test:feature:opt:long-only-ignores-short() {
	local ARGS=(-n foo);
	local name;
	args:opt name "" || return 1;
	assert "$name" "" || return 1;
	assert:array-eq ARGS "-n foo" || return 1;
}

test:feature:opt:long-only-absent() {
	local ARGS=();
	local name;
	args:opt name "" || return 1;
	assert "$name" "" || return 1;
}

# --bundle
#--------------------------------------

test:feature:flag:bundle-basic() {
	local ARGS=(-vfs);
	local verbose;
	args:flag -b verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "-fs" || return 1;
}

test:feature:flag:bundle-multiple() {
	local ARGS=(-vfs);
	local verbose force silent;
	args:flag -b verbose v || return 1;
	args:flag -b force f || return 1;
	args:flag -b silent s || return 1;
	assert "$verbose" "true" || return 1;
	assert "$force" "true" || return 1;
	assert "$silent" "true" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:flag:bundle-curl-style() {
	local ARGS=(-1fsSL https://example.com);
	local tls1 fail silent show_error follow;
	args:flag -b tls1 1 || return 1;
	args:flag -b fail f || return 1;
	args:flag -b silent s || return 1;
	args:flag -b show_error S || return 1;
	args:flag -b follow L || return 1;
	assert "$tls1" "true" || return 1;
	assert "$fail" "true" || return 1;
	assert "$silent" "true" || return 1;
	assert "$show_error" "true" || return 1;
	assert "$follow" "true" || return 1;
	assert:array-eq ARGS "https://example.com" || return 1;
}

test:feature:flag:bundle-partial() {
	local ARGS=(-vfs);
	local verbose;
	args:flag -b verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "-fs" || return 1;
}

test:feature:flag:bundle-no-match() {
	local ARGS=(-vfs);
	local other;
	args:flag -b other x || return 1;
	assert "$other" "" || return 1;
	assert:array-eq ARGS "-vfs" || return 1;
}

test:feature:flag:bundle-exact-short() {
	local ARGS=(-v);
	local verbose;
	args:flag -b verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:flag:bundle-exact-long() {
	local ARGS=(--verbose);
	local verbose;
	args:flag -b verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:flag:bundle-separator() {
	local ARGS=(-- -vfs);
	local verbose;
	args:flag -b verbose v || return 1;
	assert "$verbose" "" || return 1;
	assert:array-eq ARGS "-- -vfs" || return 1;
}

test:feature:flag:bundle-long-only() {
	local ARGS=(--verbose);
	local verbose;
	args:flag -b verbose "" || return 1;
	assert "$verbose" "true" || return 1;
}

# --count
#--------------------------------------

test:feature:flag:count-single() {
	local ARGS=(-v);
	local verbose;
	args:flag --count verbose v || return 1;
	assert "$verbose" "1" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:flag:count-multiple() {
	local ARGS=(-v -v --verbose);
	local verbose;
	args:flag --count verbose v || return 1;
	assert "$verbose" "3" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:flag:count-absent() {
	local ARGS=();
	local verbose;
	args:flag --count verbose v || return 1;
	assert "$verbose" "0" || return 1;
}

test:feature:flag:count-long-only() {
	local ARGS=(--verbose --verbose);
	local verbose;
	args:flag --count verbose "" || return 1;
	assert "$verbose" "2" || return 1;
}

# --accumulate
#--------------------------------------

test:feature:opt:accum-multiple() {
	local ARGS=(--name foo --name bar --name baz);
	local name=();
	args:opt -a name n || return 1;
	assert:array-eq name "foo bar baz" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:opt:accum-single() {
	local ARGS=(--name foo);
	local name=();
	args:opt -a name n || return 1;
	assert:array-eq name "foo" || return 1;
}

test:feature:opt:accum-absent() {
	local ARGS=();
	local name=();
	args:opt -a name n || return 1;
	assert:array-eq name "" || return 1;
}

test:feature:opt:accum-mixed-delivery() {
	local ARGS=(--name foo -nbar --name=baz);
	local name=();
	args:opt -a name n || return 1;
	assert:array-eq name "foo bar baz" || return 1;
}

test:feature:opt:accum-pattern() {
	local ARGS=(--port 8080 --port 9090);
	local port=();
	args:opt -a port p '^[0-9]+$' || return 1;
	assert:array-eq port "8080 9090" || return 1;
}

# pattern / capture-group
#--------------------------------------

test:feature:opt:pattern-match() {
	local ARGS=(--port 8080);
	local port;
	args:opt port p '^[0-9]+$' || return 1;
	assert "$port" "8080" || return 1;
}

test:feature:opt:pattern-mismatch() {
	local ARGS=(--port abc);
	local port;
	args:opt port p '^[0-9]+$' 2>/dev/null && return 1;
	return 0;
}

test:feature:opt:long-equals() {
	local ARGS=(--name=foo);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
}

test:feature:opt:short-attached() {
	local ARGS=(-nfoo);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
}

test:feature:opt:capture-group() {
	local ARGS=(--ord :100);
	local ord;
	args:opt ord o '^:([0-9]{3})$' || return 1;
	assert "$ord" "100" || return 1;
}

test:feature:arg:pattern-match() {
	local ARGS=(123);
	local num;
	args:arg num '^[0-9]+$' || return 1;
	assert "$num" "123" || return 1;
}

test:feature:arg:pattern-mismatch-required() {
	local ARGS=(abc);
	local num;
	args:arg num '^[0-9]+$' 2>/dev/null && return 1;
	return 0;
}

test:feature:arg:url-pattern-match() {
	local ARGS=(https://example.com);
	local url;
	args:arg url '^https?://' || return 1;
	assert "$url" "https://example.com" || return 1;
}

test:feature:arg:url-pattern-mismatch() {
	local ARGS=(/local/path);
	local url;
	args:arg url '^https?://' 2>/dev/null && return 1;
	return 0;
}

test:feature:arg:capture-group() {
	local ARGS=(:100);
	local ord;
	args:arg ord '^:([0-9]{3})$' || return 1;
	assert "$ord" "100" || return 1;
}

test:feature:sub:capture-group() {
	local ARGS=(clone https://repo);
	local cmd sub_args=();
	args:sub cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "clone" || return 1;
}

test:feature:sub:no-capture-group() {
	local ARGS=(clone https://repo);
	local cmd sub_args=();
	args:sub cmd sub_args '^[a-z]+$' || return 1;
	assert "$cmd" "clone" || return 1;
}

# --err
#--------------------------------------

test:feature:flag:err-required-msg() {
	local ARGS=();
	local verbose stderr;
	stderr=$(args:flag -r verbose v --err "missing --verbose" 2>&1) && return 1;
	assert "$stderr" "missing --verbose" || return 1;
}

test:feature:flag:err-optional-absent() {
	local ARGS=();
	local verbose stderr;
	stderr=$(args:flag verbose v --err "missing" 2>&1) || return 1;
	assert "$stderr" "" || return 1;
}

test:feature:flag:err-required-present() {
	local ARGS=(--verbose);
	local verbose stderr;
	stderr=$(args:flag -r verbose v --err "missing" 2>&1) || return 1;
	assert "$stderr" "" || return 1;
}

test:feature:opt:err-required-msg() {
	local ARGS=();
	local name stderr;
	stderr=$(args:opt -r name n --err "missing --name" 2>&1) && return 1;
	assert "$stderr" "missing --name" || return 1;
}

test:feature:arg:err-required-msg() {
	local ARGS=();
	local file stderr;
	stderr=$(args:arg file --err "missing file" 2>&1) && return 1;
	assert "$stderr" "missing file" || return 1;
}

test:feature:arg:err-optional-absent() {
	local ARGS=();
	local file stderr ret;
	stderr=$(args:arg -o file --err "missing file" 2>&1); ret=$?;
	assert "$ret" "0" || return 1;
	assert "$stderr" "" || return 1;
}

test:feature:varg:err-required-msg() {
	local ARGS=();
	local files stderr;
	stderr=$(args:varg files --err "missing files" 2>&1) && return 1;
	assert "$stderr" "missing files" || return 1;
}

test:feature:varg:err-required-present() {
	local ARGS=(a b c);
	local files stderr ret;
	stderr=$(args:varg files --err "missing files" 2>&1); ret=$?;
	assert "$ret" "0" || return 1;
	assert "$stderr" "" || return 1;
}

test:feature:varg:err-optional-absent() {
	local ARGS=();
	local files stderr ret;
	stderr=$(args:varg -o files --err "missing files" 2>&1); ret=$?;
	assert "$ret" "0" || return 1;
	assert "$stderr" "" || return 1;
}

test:feature:varg:err-optional-present() {
	local ARGS=(a b c);
	local files stderr ret;
	stderr=$(args:varg -o files --err "missing files" 2>&1); ret=$?;
	assert "$ret" "0" || return 1;
	assert "$stderr" "" || return 1;
}

test:feature:sub:err-required-msg() {
	local ARGS=();
	local cmd sub_args=() stderr;
	stderr=$(args:sub cmd sub_args '^([a-z]+)$' --err "missing subcommand" 2>&1) && return 1;
	assert "$stderr" "missing subcommand" || return 1;
}

# -- separator
#--------------------------------------

test:feature:flag:sep-stops() {
	local ARGS=(--verbose -- --verbose);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "-- --verbose" || return 1;
}

test:feature:flag:sep-no-match() {
	local ARGS=(-- -v);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "" || return 1;
	assert:array-eq ARGS "-- -v" || return 1;
}

test:feature:opt:sep-stops() {
	local ARGS=(--name foo -- --name bar);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
	assert:array-eq ARGS "-- --name bar" || return 1;
}

test:feature:opt:sep-no-match() {
	local ARGS=(-- --name foo);
	local name;
	args:opt name n || return 1;
	assert "$name" "" || return 1;
	assert:array-eq ARGS "-- --name foo" || return 1;
}

test:feature:opt:sep-required-after() {
	local ARGS=(-- --name foo);
	local name;
	args:opt -r name n 2>/dev/null && return 1;
	return 0;
}

test:feature:arg:sep-consumes() {
	local ARGS=(-- foo);
	local file;
	args:arg file || return 1;
	assert "$file" "foo" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:arg:sep-then-flag-like() {
	local ARGS=(-- --weird-file);
	local file;
	args:arg file || return 1;
	assert "$file" "--weird-file" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:arg:sep-only-required() {
	local ARGS=(--);
	local file;
	args:arg file 2>/dev/null && return 1;
	return 0;
}

test:feature:arg:sep-only-optional() {
	local ARGS=(--);
	local file;
	args:arg -o file || return 1;
	assert "$file" "" || return 1;
}

test:feature:arg:sep-optional-present() {
	local ARGS=(-- foo);
	local file;
	args:arg -o file || return 1;
	assert "$file" "foo" || return 1;
}

test:feature:arg:sep-pattern-match() {
	local ARGS=(-- 123);
	local num;
	args:arg num '^[0-9]+$' || return 1;
	assert "$num" "123" || return 1;
}

test:feature:arg:sep-pattern-mismatch() {
	local ARGS=(-- abc);
	local num;
	args:arg num '^[0-9]+$' 2>/dev/null && return 1;
	return 0;
}

test:feature:varg:sep-consumes() {
	local ARGS=(-- a b);
	local files;
	args:varg files || return 1;
	assert:array-eq files "a b" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:feature:varg:sep-flag-like-after() {
	local ARGS=(-- --flag -x);
	local vals;
	args:varg vals || return 1;
	assert:array-eq vals "--flag -x" || return 1;
}

test:feature:varg:sep-only-required() {
	local ARGS=(--);
	local files;
	args:varg files 2>/dev/null && return 1;
	return 0;
}

test:feature:varg:sep-only-optional() {
	local ARGS=(--);
	local files;
	args:varg -o files || return 1;
	assert:array-eq files "" || return 1;
}

test:feature:varg:sep-optional-present() {
	local ARGS=(-- a b);
	local files;
	args:varg -o files || return 1;
	assert:array-eq files "a b" || return 1;
}

test:feature:sub:sep-stops() {
	local ARGS=(--verbose -- clone);
	local cmd sub_args;
	args:sub -o cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "" || return 1;
	assert:array-eq ARGS "--verbose -- clone" || return 1;
}

test:feature:sub:sep-required-after() {
	local ARGS=(-- clone);
	local cmd sub_args=();
	args:sub cmd sub_args '^([a-z]+)$' 2>/dev/null && return 1;
	return 0;
}

test:feature:sub:sep-only-required() {
	local ARGS=(--);
	local cmd sub_args=();
	args:sub cmd sub_args '^([a-z]+)$' 2>/dev/null && return 1;
	return 0;
}

test:feature:sub:sep-only-optional() {
	local ARGS=(--);
	local cmd sub_args=();
	args:sub -o cmd sub_args '^([a-z]+)$' || return 1;
	assert "$cmd" "" || return 1;
}

# Acceptance Tests — combinations of features
#------------------------------------------------------------------------------

test:accept:flag:bundle-required() {
	local ARGS=(-vfs);
	local force;
	args:flag -r -b force f || return 1;
	assert "$force" "true" || return 1;
}

test:accept:flag:bundle-required-absent() {
	local ARGS=(-xfs);
	local verbose;
	args:flag -r -b verbose v 2>/dev/null && return 1;
	return 0;
}

test:accept:flag:bundle-with-opts() {
	local ARGS=(-o output.txt -vfs);
	local output verbose force silent;
	args:opt output o || return 1;
	args:flag -b verbose v || return 1;
	args:flag -b force f || return 1;
	args:flag -b silent s || return 1;
	assert "$output" "output.txt" || return 1;
	assert "$verbose" "true" || return 1;
	assert "$force" "true" || return 1;
	assert "$silent" "true" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:accept:flag:bundle-err() {
	local ARGS=(-xfs);
	local verbose stderr;
	stderr=$(args:flag -r -b verbose v --err "missing -v" 2>&1) && return 1;
	assert "$stderr" "missing -v" || return 1;
}

test:accept:flag:count-required-present() {
	local ARGS=(-v);
	local verbose;
	args:flag -r --count verbose v || return 1;
	assert "$verbose" "1" || return 1;
}

test:accept:flag:count-required-absent() {
	local ARGS=();
	local verbose;
	args:flag -r --count verbose v 2>/dev/null && return 1;
	return 0;
}

test:accept:flag:count-bundle() {
	local ARGS=(-vfs);
	local verbose;
	args:flag -b --count verbose v || return 1;
	assert "$verbose" "1" || return 1;
	assert:array-eq ARGS "-fs" || return 1;
}

test:accept:flag:count-bundle-multiple() {
	local ARGS=(-vfs -xv);
	local verbose;
	args:flag -b --count verbose v || return 1;
	assert "$verbose" "2" || return 1;
}

test:accept:flag:count-err-required-absent() {
	local ARGS=();
	local verbose stderr;
	stderr=$(args:flag -r --count verbose v --err "missing -v" 2>&1) && return 1;
	assert "$stderr" "missing -v" || return 1;
}

test:accept:flag:long-only-required() {
	local ARGS=(--verbose);
	local verbose;
	args:flag -r verbose "" || return 1;
	assert "$verbose" "true" || return 1;
}

test:accept:flag:long-only-required-absent() {
	local ARGS=();
	local verbose;
	args:flag -r verbose "" 2>/dev/null && return 1;
	return 0;
}

test:accept:opt:accum-required-absent() {
	local ARGS=();
	local name=();
	args:opt -r -a name n 2>/dev/null && return 1;
	return 0;
}

test:accept:opt:accum-err-required-absent() {
	local ARGS=();
	local name=() stderr;
	stderr=$(args:opt -r -a name n --err "missing --name" 2>&1) && return 1;
	assert "$stderr" "missing --name" || return 1;
}

test:accept:opt:capture-group-short() {
	local ARGS=(-o:100);
	local ord;
	args:opt ord o '^:([0-9]{3})$' || return 1;
	assert "$ord" "100" || return 1;
}

test:accept:opt:capture-group-equals() {
	local ARGS=(--ord=:100);
	local ord;
	args:opt ord o '^:([0-9]{3})$' || return 1;
	assert "$ord" "100" || return 1;
}

test:accept:opt:required-long-only() {
	local ARGS=(--name foo);
	local name;
	args:opt -r name "" || return 1;
	assert "$name" "foo" || return 1;
}

test:accept:opt:required-pattern() {
	local ARGS=(--port 8080);
	local port;
	args:opt -r port p '^[0-9]+$' || return 1;
	assert "$port" "8080" || return 1;
}

test:accept:opt:required-pattern-mismatch() {
	local ARGS=(--port abc);
	local port;
	args:opt -r port p '^[0-9]+$' 2>/dev/null && return 1;
	return 0;
}

test:accept:opt:long-only-equals() {
	local ARGS=(--name=foo);
	local name;
	args:opt name "" || return 1;
	assert "$name" "foo" || return 1;
}

test:accept:opt:pattern-match-equals() {
	local ARGS=(--port=8080);
	local port;
	args:opt port p '^[0-9]+$' || return 1;
	assert "$port" "8080" || return 1;
}

# Regression Tests — edge cases, ordering, special values
#------------------------------------------------------------------------------

test:regress:flag:mixed-args() {
	local ARGS=(-v --other);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "--other" || return 1;
}

test:regress:flag:flag-after-other() {
	local ARGS=(--other -v);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "--other" || return 1;
}

test:regress:flag:duplicate-flags() {
	local ARGS=(-v -v);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:regress:flag:equals-syntax() {
	local ARGS=(--verbose=true);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "" || return 1;
	assert:array-eq ARGS "--verbose=true" || return 1;
}

test:regress:flag:attached-value() {
	local ARGS=(-vvalue);
	local verbose;
	args:flag verbose v || return 1;
	assert "$verbose" "" || return 1;
	assert:array-eq ARGS "-vvalue" || return 1;
}

test:regress:opt:empty-value() {
	local ARGS=(--name "");
	local name;
	args:opt name n || return 1;
	assert "$name" "" || return 1;
}

test:regress:opt:mixed-args() {
	local ARGS=(--name foo --other);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
	assert:array-eq ARGS "--other" || return 1;
}

test:regress:opt:opt-after-other() {
	local ARGS=(--other --name foo);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
	assert:array-eq ARGS "--other" || return 1;
}

test:regress:opt:missing-value-long() {
	local ARGS=(--name);
	local name;
	args:opt name n '^.+$' 2>/dev/null && return 1;
	return 0;
}

test:regress:opt:missing-value-short() {
	local ARGS=(-n);
	local name;
	args:opt name n '^.+$' 2>/dev/null && return 1;
	return 0;
}

test:regress:opt:short-attached-pattern-match() {
	local ARGS=(-p8080);
	local port;
	args:opt port p '^[0-9]+$' || return 1;
	assert "$port" "8080" || return 1;
}

test:regress:opt:short-attached-pattern-mismatch() {
	local ARGS=(-pabc);
	local port;
	args:opt port p '^[0-9]+$' 2>/dev/null && return 1;
	return 0;
}

test:regress:opt:pattern-with-err-msg() {
	local ARGS=(--port abc);
	local port stderr;
	stderr=$(args:opt port p '^[0-9]+$' --err "invalid port" 2>&1) && return 1;
	assert "$stderr" "invalid port" || return 1;
}

test:regress:opt:pattern-absent-optional() {
	local ARGS=();
	local port;
	args:opt port p '^[0-9]+$' || return 1;
	assert "$port" "" || return 1;
}

test:regress:opt:special-chars() {
	local ARGS=(--name 'foo;bar');
	local name;
	args:opt name n || return 1;
	assert "$name" 'foo;bar' || return 1;
}

test:regress:opt:newline-in-value() {
	local ARGS=(--name $'foo\nbar');
	local name;
	args:opt name n || return 1;
	assert "$name" $'foo\nbar' || return 1;
}

test:regress:opt:unicode() {
	local ARGS=(--name '日本語');
	local name;
	args:opt name n || return 1;
	assert "$name" '日本語' || return 1;
}

test:regress:opt:equals-in-value() {
	local ARGS=(--name=foo=bar);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo=bar" || return 1;
}

test:regress:opt:spaces-via-equals() {
	local ARGS=(--name='foo bar');
	local name;
	args:opt name n || return 1;
	assert "$name" 'foo bar' || return 1;
}

test:regress:opt:hyphen-value() {
	local ARGS=(--name -);
	local name;
	args:opt name n || return 1;
	assert "$name" "-" || return 1;
}

test:regress:arg:first-of-many() {
	local ARGS=(foo bar baz);
	local first;
	args:arg first || return 1;
	assert "$first" "foo" || return 1;
	assert:array-eq ARGS "bar baz" || return 1;
}

test:regress:arg:empty-string() {
	local ARGS=("");
	local val;
	args:arg val || return 1;
	assert "$val" "" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:regress:arg:flag-like() {
	local ARGS=(--flag);
	local val;
	args:arg val || return 1;
	assert "$val" "--flag" || return 1;
}

test:regress:arg:optional-skip-non-match() {
	local ARGS=(abc 123);
	local num;
	args:arg -o num '^[0-9]+$' || return 1;
	assert "$num" "" || return 1;
	assert:array-eq ARGS "abc 123" || return 1;
}

test:regress:arg:stdin-marker() {
	local ARGS=(-);
	local file;
	args:arg file || return 1;
	assert "$file" "-" || return 1;
}

test:regress:arg:pattern-with-err-msg() {
	local ARGS=(abc);
	local num stderr;
	stderr=$(args:arg num '^[0-9]+$' --err "must be number" 2>&1) && return 1;
	assert "$stderr" "must be number" || return 1;
}

test:regress:varg:empty-strings() {
	local ARGS=("" "" "");
	local vals;
	args:varg vals || return 1;
	assert "${#vals[@]}" "3" || return 1;
	assert "${vals[0]}" "" || return 1;
}

test:regress:varg:flag-like-values() {
	local ARGS=(--flag -x value);
	local vals;
	args:varg vals || return 1;
	assert:array-eq vals "--flag -x value" || return 1;
}

test:regress:varg:spaces() {
	local ARGS=(a "b c" d);
	local vals;
	args:varg vals || return 1;
	assert "${#vals[@]}" "3" || return 1;
	assert "${vals[1]}" "b c" || return 1;
}

# Integration Tests — multiple functions together
#------------------------------------------------------------------------------

test:int:flag-opt-arg() {
	local ARGS=(-v --name foo bar);
	local verbose name file;
	args:flag verbose v || return 1;
	args:opt name n || return 1;
	args:arg file || return 1;
	assert "$verbose" "true" || return 1;
	assert "$name" "foo" || return 1;
	assert "$file" "bar" || return 1;
}

test:int:order-independence() {
	local ARGS=(bar --name foo -v);
	local verbose name file;
	args:flag verbose v || return 1;
	args:opt name n || return 1;
	args:arg file || return 1;
	assert "$verbose" "true" || return 1;
	assert "$name" "foo" || return 1;
	assert "$file" "bar" || return 1;
}

test:int:opt-arg-patterns() {
	local ARGS=(--url https://x.com /local/path);
	local url path;
	args:opt url u '^https?://' || return 1;
	args:arg path || return 1;
	assert "$url" "https://x.com" || return 1;
	assert "$path" "/local/path" || return 1;
}

test:int:flag-varg() {
	local ARGS=(-v a b c);
	local verbose files;
	args:flag verbose v || return 1;
	args:varg files || return 1;
	assert "$verbose" "true" || return 1;
	assert:array-eq files "a b c" || return 1;
}

test:int:duplicate-opts-first-wins() {
	local ARGS=(--name foo --name bar);
	local name;
	args:opt name n || return 1;
	assert "$name" "foo" || return 1;
	assert:array-eq ARGS "" || return 1;
}

test:int:early-exit-required() {
	local ARGS=();
	local verbose name;
	args:flag verbose v || return 1;
	args:opt -r name n 2>/dev/null && return 1;
	return 0;
}

test:int:full-pipeline-with-separator() {
	local ARGS=(-v --name foo -- --weird-file -rf);
	local verbose name file extra;
	args:flag verbose v || return 1;
	args:opt name n || return 1;
	args:arg file || return 1;
	args:varg -o extra || return 1;
	assert "$verbose" "true" || return 1;
	assert "$name" "foo" || return 1;
	assert "$file" "--weird-file" || return 1;
	assert:array-eq extra "-rf" || return 1;
}

test:int:multiple-args-across-separator() {
	local ARGS=(pos1 -- pos2 pos3);
	local a1 a2 a3;
	args:arg a1 || return 1;
	args:arg a2 || return 1;
	args:arg a3 || return 1;
	assert "$a1" "pos1" || return 1;
	assert "$a2" "pos2" || return 1;
	assert "$a3" "pos3" || return 1;
}

# Output
#------------------------------------------------------------------------------

output() {
cat <<MD
# args Test Results

## Smoke Tests

Scenario              | Function | Invocation                             | Arguments                    | Expected                                         | Status | ✓/✗
--------------------- | -------- | -------------------------------------- | ---------------------------- | ------------------------------------------------ | ------ | -----------------------------------
flag:long             | flag     | args:flag verbose v                    | --verbose                    | true                                             |      0 | $(test smoke:flag:long)
flag:short            | flag     | args:flag verbose v                    | -v                           | true                                             |      0 | $(test smoke:flag:short)
flag:absent           | flag     | args:flag verbose v                    | *(none)*                     | ""                                               |      0 | $(test smoke:flag:absent)
opt:long-space        | opt      | args:opt name n                        | --name foo                   | foo                                              |      0 | $(test smoke:opt:long-space)
opt:short-space       | opt      | args:opt name n                        | -n foo                       | foo                                              |      0 | $(test smoke:opt:short-space)
opt:absent            | opt      | args:opt name n                        | *(none)*                     | ""                                               |      0 | $(test smoke:opt:absent)
arg:positional        | arg      | args:arg file                          | foo                          | foo                                              |      0 | $(test smoke:arg:positional)
arg:missing           | arg      | args:arg file                          | *(none)*                     | -                                                |      1 | $(test smoke:arg:missing)
arg:optional-missing  | arg      | args:arg -o file                       | *(none)*                     | ""                                               |      0 | $(test smoke:arg:optional-missing)
varg:variadic         | varg     | args:varg files                        | a b c                        | (a b c)                                          |      0 | $(test smoke:varg:variadic)
varg:missing          | varg     | args:varg files                        | *(none)*                     | -                                                |      1 | $(test smoke:varg:missing)
varg:optional-missing | varg     | args:varg -o files                     | *(none)*                     | ()                                               |      0 | $(test smoke:varg:optional-missing)
sub:match             | sub      | args:sub cmd sub_args '^([a-z]+)\$'    | --verbose clone https://repo | clone, sub_args=(https://repo), ARGS=(--verbose) |      0 | $(test smoke:sub:match)
sub:missing           | sub      | args:sub cmd sub_args '^([a-z]+)\$'    | *(none)*                     | -                                                |      1 | $(test smoke:sub:missing)
sub:optional-missing  | sub      | args:sub -o cmd sub_args '^([a-z]+)\$' | *(none)*                     | ""                                               |      0 | $(test smoke:sub:optional-missing)

---

## Feature Tests

### --required / --optional
Scenario                      | Function | Invocation                             | Arguments                            | Expected                        | Status | ✓/✗
----------------------------- | -------- | -------------------------------------- | ------------------------------------ | ------------------------------- | ------ | ---------------------------------------------
flag:required-found           | flag     | args:flag -r verbose v                 | --verbose                            | true                            |      0 | $(test feature:flag:required-found)
flag:required-missing         | flag     | args:flag -r verbose v                 | *(none)*                             | -                               |      1 | $(test feature:flag:required-missing)
flag:required-multiple        | flag     | args:flag -r verbose v                 | -v -v                                | true                            |      0 | $(test feature:flag:required-multiple)
flag:required-after-sep       | flag     | args:flag -r verbose v                 | -- -v                                | -                               |      1 | $(test feature:flag:required-after-sep)
opt:required-found            | opt      | args:opt -r name n                     | --name foo                           | foo                             |      0 | $(test feature:opt:required-found)
opt:required-missing          | opt      | args:opt -r name n                     | *(none)*                             | -                               |      1 | $(test feature:opt:required-missing)
opt:required-long-only-absent | opt      | args:opt -r name ""                    | *(none)*                             | -                               |      1 | $(test feature:opt:required-long-only-absent)
arg:optional-present          | arg      | args:arg -o file                       | foo                                  | foo, ARGS=()                    |      0 | $(test feature:arg:optional-present)
arg:optional-pattern-match    | arg      | args:arg -o num '^[0-9]+\$'            | 123                                  | 123                             |      0 | $(test feature:arg:optional-pattern-match)
arg:optional-pattern-mismatch | arg      | args:arg -o num '^[0-9]+\$'            | abc                                  | "", ARGS=(abc)                  |      0 | $(test feature:arg:optional-pattern-mismatch)
varg:single-arg               | varg     | args:varg files                        | single                               | (single)                        |      0 | $(test feature:varg:single-arg)
varg:optional-present         | varg     | args:varg -o files                     | a b c                                | (a b c)                         |      0 | $(test feature:varg:optional-present)
varg:optional-single          | varg     | args:varg -o files                     | single                               | (single)                        |      0 | $(test feature:varg:optional-single)
sub:optional-match            | sub      | args:sub -o cmd sub_args '^([a-z]+)\$' | clone https://repo                   | clone                           |      0 | $(test feature:sub:optional-match)
sub:required-mismatch         | sub      | args:sub cmd sub_args '^([a-z]+)\$'    | --verbose --force                    | -                               |      1 | $(test feature:sub:required-mismatch)
sub:optional-mismatch         | sub      | args:sub -o cmd sub_args '^([a-z]+)\$' | --verbose --force                    | ""                              |      0 | $(test feature:sub:optional-mismatch)
sub:flags-before              | sub      | args:sub cmd sub_args '^([a-z]+)\$'    | --verbose --force clone https://repo | clone, ARGS=(--verbose --force) |      0 | $(test feature:sub:flags-before)

### long-only
Scenario                     | Function | Invocation           | Arguments  | Expected          | Status | ✓/✗
---------------------------- | -------- | -------------------- | ---------- | ----------------- | ------ | --------------------------------------------
flag:long-only               | flag     | args:flag verbose "" | --verbose  | true              |      0 | $(test feature:flag:long-only)
flag:long-only-ignores-short | flag     | args:flag verbose "" | -v         | "", ARGS=(-v)     |      0 | $(test feature:flag:long-only-ignores-short)
flag:long-only-absent        | flag     | args:flag verbose "" | *(none)*   | ""                |      0 | $(test feature:flag:long-only-absent)
opt:long-only                | opt      | args:opt name ""     | --name foo | foo               |      0 | $(test feature:opt:long-only)
opt:long-only-ignores-short  | opt      | args:opt name ""     | -n foo     | "", ARGS=(-n foo) |      0 | $(test feature:opt:long-only-ignores-short)
opt:long-only-absent         | opt      | args:opt name ""     | *(none)*   | ""                |      0 | $(test feature:opt:long-only-absent)

### --bundle
Scenario                | Function | Invocation                                                                                                        | Arguments          | Expected           | Status | ✓/✗
----------------------- | -------- | ----------------------------------------------------------------------------------------------------------------- | ------------------ | ------------------ | ------ | ---------------------------------------
flag:bundle-basic       | flag     | args:flag -b verbose v                                                                                            | -vfs               | true, ARGS=(-fs)   |      0 | $(test feature:flag:bundle-basic)
flag:bundle-multiple    | flag     | args:flag -b verbose v; args:flag -b force f; args:flag -b silent s                                               | -vfs               | all true, ARGS=()  |      0 | $(test feature:flag:bundle-multiple)
flag:bundle-curl-style  | flag     | args:flag -b tls1 1; args:flag -b fail f; args:flag -b silent s; args:flag -b show_error S; args:flag -b follow L | -1fsSL https://... | all true           |      0 | $(test feature:flag:bundle-curl-style)
flag:bundle-partial     | flag     | args:flag -b verbose v                                                                                            | -vfs               | true, ARGS=(-fs)   |      0 | $(test feature:flag:bundle-partial)
flag:bundle-no-match    | flag     | args:flag -b other x                                                                                              | -vfs               | "", ARGS=(-vfs)    |      0 | $(test feature:flag:bundle-no-match)
flag:bundle-exact-short | flag     | args:flag -b verbose v                                                                                            | -v                 | true, ARGS=()      |      0 | $(test feature:flag:bundle-exact-short)
flag:bundle-exact-long  | flag     | args:flag -b verbose v                                                                                            | --verbose          | true, ARGS=()      |      0 | $(test feature:flag:bundle-exact-long)
flag:bundle-separator   | flag     | args:flag -b verbose v                                                                                            | -- -vfs            | "", ARGS=(-- -vfs) |      0 | $(test feature:flag:bundle-separator)
flag:bundle-long-only   | flag     | args:flag -b verbose ""                                                                                           | --verbose          | true               |      0 | $(test feature:flag:bundle-long-only)

### --count
Scenario             | Function | Invocation                   | Arguments           | Expected   | Status | ✓/✗
-------------------- | -------- | ---------------------------- | ------------------- | ---------- | ------ | ------------------------------------
flag:count-single    | flag     | args:flag --count verbose v  | -v                  | 1, ARGS=() |      0 | $(test feature:flag:count-single)
flag:count-multiple  | flag     | args:flag --count verbose v  | -v -v --verbose     | 3, ARGS=() |      0 | $(test feature:flag:count-multiple)
flag:count-absent    | flag     | args:flag --count verbose v  | *(none)*            | 0          |      0 | $(test feature:flag:count-absent)
flag:count-long-only | flag     | args:flag --count verbose "" | --verbose --verbose | 2          |      0 | $(test feature:flag:count-long-only)

### --accumulate
Scenario                 | Function | Invocation                     | Arguments                        | Expected      | Status | ✓/✗
------------------------ | -------- | ------------------------------ | -------------------------------- | ------------- | ------ | ----------------------------------------
opt:accum-multiple       | opt      | args:opt -a name n             | --name foo --name bar --name baz | (foo bar baz) |      0 | $(test feature:opt:accum-multiple)
opt:accum-single         | opt      | args:opt -a name n             | --name foo                       | (foo)         |      0 | $(test feature:opt:accum-single)
opt:accum-absent         | opt      | args:opt -a name n             | *(none)*                         | ()            |      0 | $(test feature:opt:accum-absent)
opt:accum-mixed-delivery | opt      | args:opt -a name n             | --name foo -nbar --name=baz      | (foo bar baz) |      0 | $(test feature:opt:accum-mixed-delivery)
opt:accum-pattern        | opt      | args:opt -a port p '^[0-9]+\$' | --port 8080 --port 9090          | (8080 9090)   |      0 | $(test feature:opt:accum-pattern)

### pattern / capture-group
Scenario                      | Function | Invocation                          | Arguments           | Expected            | Status | ✓/✗
----------------------------- | -------- | ----------------------------------- | ------------------- | ------------------- | ------ | ---------------------------------------------
opt:pattern-match             | opt      | args:opt port p '^[0-9]+\$'         | --port 8080         | 8080                |      0 | $(test feature:opt:pattern-match)
opt:pattern-mismatch          | opt      | args:opt port p '^[0-9]+\$'         | --port abc          | -                   |      1 | $(test feature:opt:pattern-mismatch)
opt:long-equals               | opt      | args:opt name n                     | --name=foo          | foo                 |      0 | $(test feature:opt:long-equals)
opt:short-attached            | opt      | args:opt name n                     | -nfoo               | foo                 |      0 | $(test feature:opt:short-attached)
opt:capture-group             | opt      | args:opt ord o '^:([0-9]{3})\$'     | --ord :100          | 100                 |      0 | $(test feature:opt:capture-group)
arg:pattern-match             | arg      | args:arg num '^[0-9]+\$'            | 123                 | 123                 |      0 | $(test feature:arg:pattern-match)
arg:pattern-mismatch-required | arg      | args:arg num '^[0-9]+\$'            | abc                 | -                   |      1 | $(test feature:arg:pattern-mismatch-required)
arg:url-pattern-match         | arg      | args:arg url '^https?://'           | https://example.com | https://example.com |      0 | $(test feature:arg:url-pattern-match)
arg:url-pattern-mismatch      | arg      | args:arg url '^https?://'           | /local/path         | -                   |      1 | $(test feature:arg:url-pattern-mismatch)
arg:capture-group             | arg      | args:arg ord '^:([0-9]{3})\$'       | :100                | 100                 |      0 | $(test feature:arg:capture-group)
sub:capture-group             | sub      | args:sub cmd sub_args '^([a-z]+)\$' | clone https://repo  | clone               |      0 | $(test feature:sub:capture-group)
sub:no-capture-group          | sub      | args:sub cmd sub_args '^[a-z]+\$'   | clone https://repo  | clone               |      0 | $(test feature:sub:no-capture-group)

### --err
Scenario                  | Function | Invocation                                      | Arguments | Expected  | Status | ✓/✗
------------------------- | -------- | ----------------------------------------------- | --------- | --------- | ------ | -----------------------------------------
flag:err-required-msg     | flag     | args:flag -r verbose v --err "..."              | *(none)*  | stderr    |      1 | $(test feature:flag:err-required-msg)
flag:err-optional-absent  | flag     | args:flag verbose v --err "..."                 | *(none)*  | no stderr |      0 | $(test feature:flag:err-optional-absent)
flag:err-required-present | flag     | args:flag -r verbose v --err "..."              | --verbose | no stderr |      0 | $(test feature:flag:err-required-present)
opt:err-required-msg      | opt      | args:opt -r name n --err "..."                  | *(none)*  | stderr    |      1 | $(test feature:opt:err-required-msg)
arg:err-required-msg      | arg      | args:arg file --err "..."                       | *(none)*  | stderr    |      1 | $(test feature:arg:err-required-msg)
arg:err-optional-absent   | arg      | args:arg -o file --err "..."                    | *(none)*  | no stderr |      0 | $(test feature:arg:err-optional-absent)
varg:err-required-msg     | varg     | args:varg files --err "..."                     | *(none)*  | stderr    |      1 | $(test feature:varg:err-required-msg)
varg:err-required-present | varg     | args:varg files --err "..."                     | a b c     | no stderr |      0 | $(test feature:varg:err-required-present)
varg:err-optional-absent  | varg     | args:varg -o files --err "..."                  | *(none)*  | no stderr |      0 | $(test feature:varg:err-optional-absent)
varg:err-optional-present | varg     | args:varg -o files --err "..."                  | a b c     | no stderr |      0 | $(test feature:varg:err-optional-present)
sub:err-required-msg      | sub      | args:sub cmd sub_args '^([a-z]+)\$' --err "..." | *(none)*  | stderr    |      1 | $(test feature:sub:err-required-msg)

### -- separator
Scenario                  | Function | Invocation                             | Arguments                | Expected                      | Status | ✓/✗
------------------------- | -------- | -------------------------------------- | ------------------------ | ----------------------------- | ------ | -----------------------------------------
flag:sep-stops            | flag     | args:flag verbose v                    | --verbose -- --verbose   | true, ARGS=(-- --verbose)     |      0 | $(test feature:flag:sep-stops)
flag:sep-no-match         | flag     | args:flag verbose v                    | -- -v                    | "", ARGS=(-- -v)              |      0 | $(test feature:flag:sep-no-match)
opt:sep-stops             | opt      | args:opt name n                        | --name foo -- --name bar | foo, ARGS=(-- --name bar)     |      0 | $(test feature:opt:sep-stops)
opt:sep-no-match          | opt      | args:opt name n                        | -- --name foo            | "", ARGS=(-- --name foo)      |      0 | $(test feature:opt:sep-no-match)
opt:sep-required-after    | opt      | args:opt -r name n                     | -- --name foo            | -                             |      1 | $(test feature:opt:sep-required-after)
arg:sep-consumes          | arg      | args:arg file                          | -- foo                   | foo                           |      0 | $(test feature:arg:sep-consumes)
arg:sep-then-flag-like    | arg      | args:arg file                          | -- --weird-file          | --weird-file                  |      0 | $(test feature:arg:sep-then-flag-like)
arg:sep-only-required     | arg      | args:arg file                          | --                       | -                             |      1 | $(test feature:arg:sep-only-required)
arg:sep-only-optional     | arg      | args:arg -o file                       | --                       | ""                            |      0 | $(test feature:arg:sep-only-optional)
arg:sep-optional-present  | arg      | args:arg -o file                       | -- foo                   | foo                           |      0 | $(test feature:arg:sep-optional-present)
arg:sep-pattern-match     | arg      | args:arg num '^[0-9]+\$'               | -- 123                   | 123                           |      0 | $(test feature:arg:sep-pattern-match)
arg:sep-pattern-mismatch  | arg      | args:arg num '^[0-9]+\$'               | -- abc                   | -                             |      1 | $(test feature:arg:sep-pattern-mismatch)
varg:sep-consumes         | varg     | args:varg files                        | -- a b                   | (a b)                         |      0 | $(test feature:varg:sep-consumes)
varg:sep-flag-like-after  | varg     | args:varg vals                         | -- --flag -x             | (--flag -x)                   |      0 | $(test feature:varg:sep-flag-like-after)
varg:sep-only-required    | varg     | args:varg files                        | --                       | -                             |      1 | $(test feature:varg:sep-only-required)
varg:sep-only-optional    | varg     | args:varg -o files                     | --                       | ()                            |      0 | $(test feature:varg:sep-only-optional)
varg:sep-optional-present | varg     | args:varg -o files                     | -- a b                   | (a b)                         |      0 | $(test feature:varg:sep-optional-present)
sub:sep-stops             | sub      | args:sub -o cmd sub_args '^([a-z]+)\$' | --verbose -- clone       | "", ARGS=(--verbose -- clone) |      0 | $(test feature:sub:sep-stops)
sub:sep-required-after    | sub      | args:sub cmd sub_args '^([a-z]+)\$'    | -- clone                 | -                             |      1 | $(test feature:sub:sep-required-after)
sub:sep-only-required     | sub      | args:sub cmd sub_args '^([a-z]+)\$'    | --                       | -                             |      1 | $(test feature:sub:sep-only-required)
sub:sep-only-optional     | sub      | args:sub -o cmd sub_args '^([a-z]+)\$' | --                       | ""                            |      0 | $(test feature:sub:sep-only-optional)

---

## Acceptance Tests

Scenario                       | Function | Invocation                                                                             | Arguments          | Expected      | Status | ✓/✗
------------------------------ | -------- | -------------------------------------------------------------------------------------- | ------------------ | ------------- | ------ | ---------------------------------------------
flag:bundle-required           | flag     | args:flag -r -b force f                                                                | -vfs               | true          |      0 | $(test accept:flag:bundle-required)
flag:bundle-required-absent    | flag     | args:flag -r -b verbose v                                                              | -xfs               | -             |      1 | $(test accept:flag:bundle-required-absent)
flag:bundle-with-opts          | flag     | args:opt output o; args:flag -b verbose v; args:flag -b force f; args:flag -b silent s | -o output.txt -vfs | all parsed    |      0 | $(test accept:flag:bundle-with-opts)
flag:bundle-err                | flag     | args:flag -r -b verbose v --err "..."                                                  | -xfs               | stderr        |      1 | $(test accept:flag:bundle-err)
flag:count-required-present    | flag     | args:flag -r --count verbose v                                                         | -v                 | 1             |      0 | $(test accept:flag:count-required-present)
flag:count-required-absent     | flag     | args:flag -r --count verbose v                                                         | *(none)*           | -             |      1 | $(test accept:flag:count-required-absent)
flag:count-bundle              | flag     | args:flag -b --count verbose v                                                         | -vfs               | 1, ARGS=(-fs) |      0 | $(test accept:flag:count-bundle)
flag:count-bundle-multiple     | flag     | args:flag -b --count verbose v                                                         | -vfs -xv           | 2             |      0 | $(test accept:flag:count-bundle-multiple)
flag:count-err-required-absent | flag     | args:flag -r --count verbose v --err "."                                               | *(none)*           | stderr        |      1 | $(test accept:flag:count-err-required-absent)
flag:long-only-required        | flag     | args:flag -r verbose ""                                                                | --verbose          | true          |      0 | $(test accept:flag:long-only-required)
flag:long-only-required-absent | flag     | args:flag -r verbose ""                                                                | *(none)*           | -             |      1 | $(test accept:flag:long-only-required-absent)
opt:accum-required-absent      | opt      | args:opt -r -a name n                                                                  | *(none)*           | -             |      1 | $(test accept:opt:accum-required-absent)
opt:accum-err-required-absent  | opt      | args:opt -r -a name n --err "..."                                                      | *(none)*           | stderr        |      1 | $(test accept:opt:accum-err-required-absent)
opt:capture-group-short        | opt      | args:opt ord o '^:([0-9]{3})\$'                                                        | -o:100             | 100           |      0 | $(test accept:opt:capture-group-short)
opt:capture-group-equals       | opt      | args:opt ord o '^:([0-9]{3})\$'                                                        | --ord=:100         | 100           |      0 | $(test accept:opt:capture-group-equals)
opt:required-long-only         | opt      | args:opt -r name ""                                                                    | --name foo         | foo           |      0 | $(test accept:opt:required-long-only)
opt:required-pattern           | opt      | args:opt -r port p '^[0-9]+\$'                                                         | --port 8080        | 8080          |      0 | $(test accept:opt:required-pattern)
opt:required-pattern-mismatch  | opt      | args:opt -r port p '^[0-9]+\$'                                                         | --port abc         | -             |      1 | $(test accept:opt:required-pattern-mismatch)
opt:long-only-equals           | opt      | args:opt name ""                                                                       | --name=foo         | foo           |      0 | $(test accept:opt:long-only-equals)
opt:pattern-match-equals       | opt      | args:opt port p '^[0-9]+\$'                                                            | --port=8080        | 8080          |      0 | $(test accept:opt:pattern-match-equals)

---

## Regression Tests

Scenario                            | Function | Invocation                              | Arguments            | Expected                  | Status | ✓/✗
----------------------------------- | -------- | --------------------------------------- | -------------------- | ------------------------- | ------ | ---------------------------------------------------
flag:mixed-args                     | flag     | args:flag verbose v                     | -v --other           | true, ARGS=(--other)      |      0 | $(test regress:flag:mixed-args)
flag:flag-after-other               | flag     | args:flag verbose v                     | --other -v           | true, ARGS=(--other)      |      0 | $(test regress:flag:flag-after-other)
flag:duplicate-flags                | flag     | args:flag verbose v                     | -v -v                | true, ARGS=()             |      0 | $(test regress:flag:duplicate-flags)
flag:equals-syntax                  | flag     | args:flag verbose v                     | --verbose=true       | "", ARGS=(--verbose=true) |      0 | $(test regress:flag:equals-syntax)
flag:attached-value                 | flag     | args:flag verbose v                     | -vvalue              | "", ARGS=(-vvalue)        |      0 | $(test regress:flag:attached-value)
opt:empty-value                     | opt      | args:opt name n                         | --name ""            | ""                        |      0 | $(test regress:opt:empty-value)
opt:mixed-args                      | opt      | args:opt name n                         | --name foo --other   | foo, ARGS=(--other)       |      0 | $(test regress:opt:mixed-args)
opt:opt-after-other                 | opt      | args:opt name n                         | --other --name foo   | foo, ARGS=(--other)       |      0 | $(test regress:opt:opt-after-other)
opt:missing-value-long              | opt      | args:opt name n '^.+\$'                 | --name               | -                         |      1 | $(test regress:opt:missing-value-long)
opt:missing-value-short             | opt      | args:opt name n '^.+\$'                 | -n                   | -                         |      1 | $(test regress:opt:missing-value-short)
opt:short-attached-pattern-match    | opt      | args:opt port p '^[0-9]+\$'             | -p8080               | 8080                      |      0 | $(test regress:opt:short-attached-pattern-match)
opt:short-attached-pattern-mismatch | opt      | args:opt port p '^[0-9]+\$'             | -pabc                | -                         |      1 | $(test regress:opt:short-attached-pattern-mismatch)
opt:pattern-with-err-msg            | opt      | args:opt port p '^[0-9]+\$' --err "..." | --port abc           | stderr                    |      1 | $(test regress:opt:pattern-with-err-msg)
opt:pattern-absent-optional         | opt      | args:opt port p '^[0-9]+\$'             | *(none)*             | ""                        |      0 | $(test regress:opt:pattern-absent-optional)
opt:special-chars                   | opt      | args:opt name n                         | --name 'foo;bar'     | foo;bar                   |      0 | $(test regress:opt:special-chars)
opt:newline-in-value                | opt      | args:opt name n                         | --name \$'foo\\nbar' | foo\\nbar                 |      0 | $(test regress:opt:newline-in-value)
opt:unicode                         | opt      | args:opt name n                         | --name '日本語'      | 日本語                    |      0 | $(test regress:opt:unicode)
opt:equals-in-value                 | opt      | args:opt name n                         | --name=foo=bar       | foo=bar                   |      0 | $(test regress:opt:equals-in-value)
opt:spaces-via-equals               | opt      | args:opt name n                         | --name='foo bar'     | foo bar                   |      0 | $(test regress:opt:spaces-via-equals)
opt:hyphen-value                    | opt      | args:opt name n                         | --name -             | "-"                       |      0 | $(test regress:opt:hyphen-value)
arg:first-of-many                   | arg      | args:arg first                          | foo bar baz          | foo, ARGS=(bar baz)       |      0 | $(test regress:arg:first-of-many)
arg:empty-string                    | arg      | args:arg val                            | ""                   | ""                        |      0 | $(test regress:arg:empty-string)
arg:flag-like                       | arg      | args:arg val                            | --flag               | --flag                    |      0 | $(test regress:arg:flag-like)
arg:optional-skip-non-match         | arg      | args:arg -o num '^[0-9]+\$'             | abc 123              | "", ARGS=(abc 123)        |      0 | $(test regress:arg:optional-skip-non-match)
arg:stdin-marker                    | arg      | args:arg file                           | -                    | "-"                       |      0 | $(test regress:arg:stdin-marker)
arg:pattern-with-err-msg            | arg      | args:arg num '^[0-9]+\$' --err "..."    | abc                  | stderr                    |      1 | $(test regress:arg:pattern-with-err-msg)
varg:empty-strings                  | varg     | args:varg vals                          | "" "" ""             | ("" "" "")                |      0 | $(test regress:varg:empty-strings)
varg:flag-like-values               | varg     | args:varg vals                          | --flag -x value      | (--flag -x value)         |      0 | $(test regress:varg:flag-like-values)
varg:spaces                         | varg     | args:varg vals                          | a "b c" d            | (a "b c" d)               |      0 | $(test regress:varg:spaces)

---

## Integration Tests

Scenario                       | Invocation                                                              | Arguments                    | Expected        | Status | ✓/✗
------------------------------ | ----------------------------------------------------------------------- | ---------------------------- | --------------- | ------ | ------------------------------------------
flag-opt-arg                   | args:flag verbose v; args:opt name n; args:arg file                     | -v --name foo bar            | all parsed      |      0 | $(test int:flag-opt-arg)
order-independence             | args:flag verbose v; args:opt name n; args:arg file                     | bar --name foo -v            | all parsed      |      0 | $(test int:order-independence)
opt-arg-patterns               | args:opt url u '^https?://'; args:arg path                              | --url https://x.com /path    | both matched    |      0 | $(test int:opt-arg-patterns)
flag-varg                      | args:flag verbose v; args:varg files                                    | -v a b c                     | verbose + files |      0 | $(test int:flag-varg)
duplicate-opts-first-wins      | args:opt name n                                                         | --name foo --name bar        | foo (first)     |      0 | $(test int:duplicate-opts-first-wins)
early-exit-required            | args:flag verbose v; args:opt -r name n                                 | *(none)*                     | early exit      |      1 | $(test int:early-exit-required)
full-pipeline-with-separator   | args:flag verbose v; args:opt name n; args:arg file; args:varg -o extra | -v --name foo -- --weird -rf | all parsed      |      0 | $(test int:full-pipeline-with-separator)
multiple-args-across-separator | args:arg a1; args:arg a2; args:arg a3                                   | pos1 -- pos2 pos3            | all parsed      |      0 | $(test int:multiple-args-across-separator)

MD
}
